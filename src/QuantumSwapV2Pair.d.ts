// Auto-generated by sdkgen
import { Contract, ContractRunner, ContractTransactionResponse, TransactionResponse } from "quantumcoin";
import type * as Types from "./types";

export declare class QuantumSwapV2Pair extends Contract {
  static readonly abi: readonly any[];
  static readonly bytecode: string;
  static connect(address: string, runner?: ContractRunner): QuantumSwapV2Pair;
  constructor(address: string, runner?: ContractRunner, _deployTx?: TransactionResponse);
  readonly populateTransaction: {
    approve(spender: Types.AddressLike, value: Types.Uint256Like, overrides?: any): Promise<import("quantumcoin").TransactionRequest>;
    burn(to: Types.AddressLike, overrides?: any): Promise<import("quantumcoin").TransactionRequest>;
    initialize(_token0: Types.AddressLike, _token1: Types.AddressLike, overrides?: any): Promise<import("quantumcoin").TransactionRequest>;
    mint(to: Types.AddressLike, overrides?: any): Promise<import("quantumcoin").TransactionRequest>;
    skim(to: Types.AddressLike, overrides?: any): Promise<import("quantumcoin").TransactionRequest>;
    swap(amount0Out: Types.Uint256Like, amount1Out: Types.Uint256Like, to: Types.AddressLike, data: Types.BytesLike, overrides?: any): Promise<import("quantumcoin").TransactionRequest>;
    sync(overrides?: any): Promise<import("quantumcoin").TransactionRequest>;
    transfer(to: Types.AddressLike, value: Types.Uint256Like, overrides?: any): Promise<import("quantumcoin").TransactionRequest>;
    transferFrom(from: Types.AddressLike, to: Types.AddressLike, value: Types.Uint256Like, overrides?: any): Promise<import("quantumcoin").TransactionRequest>;
  };
  MINIMUM_LIQUIDITY(): Promise<Types.Uint256>;
  allowance(arg0: Types.AddressLike, arg1: Types.AddressLike): Promise<Types.Uint256>;
  approve(spender: Types.AddressLike, value: Types.Uint256Like, overrides?: any): Promise<ContractTransactionResponse>;
  balanceOf(arg0: Types.AddressLike): Promise<Types.Uint256>;
  burn(to: Types.AddressLike, overrides?: any): Promise<ContractTransactionResponse>;
  decimals(): Promise<Types.Uint8>;
  factory(): Promise<Types.SolAddress>;
  getReserves(): Promise<[Types.Uint112, Types.Uint112, Types.Uint32]>;
  initialize(_token0: Types.AddressLike, _token1: Types.AddressLike, overrides?: any): Promise<ContractTransactionResponse>;
  kLast(): Promise<Types.Uint256>;
  mint(to: Types.AddressLike, overrides?: any): Promise<ContractTransactionResponse>;
  name(): Promise<string>;
  price0CumulativeLast(): Promise<Types.Uint256>;
  price1CumulativeLast(): Promise<Types.Uint256>;
  skim(to: Types.AddressLike, overrides?: any): Promise<ContractTransactionResponse>;
  swap(amount0Out: Types.Uint256Like, amount1Out: Types.Uint256Like, to: Types.AddressLike, data: Types.BytesLike, overrides?: any): Promise<ContractTransactionResponse>;
  symbol(): Promise<string>;
  sync(overrides?: any): Promise<ContractTransactionResponse>;
  token0(): Promise<Types.SolAddress>;
  token1(): Promise<Types.SolAddress>;
  totalSupply(): Promise<Types.Uint256>;
  transfer(to: Types.AddressLike, value: Types.Uint256Like, overrides?: any): Promise<ContractTransactionResponse>;
  transferFrom(from: Types.AddressLike, to: Types.AddressLike, value: Types.Uint256Like, overrides?: any): Promise<ContractTransactionResponse>;
}
